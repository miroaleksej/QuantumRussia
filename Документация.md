# Документация к фреймворку "РуКвант"

## Оглавление
1. [Введение](#введение)
2. [Быстрый старт](#быстрый-старт)
3. [Основные компоненты](#основные-компоненты)
   - [Квантовые схемы](#квантовые-схемы)
   - [Симуляторы](#симуляторы)
   - [Гибридные вычисления](#гибридные-вычисления)
   - [Аппаратная интеграция](#аппаратная-интеграция)
4. [Примеры использования](#примеры-использования)
5. [API Reference](#api-reference)
6. [Разработка и вклад](#разработка-и-вклад)

## Введение

**РуКвант** - это российский фреймворк для квантовых вычислений, разработанный как альтернатива западным аналогам (Qiskit, Cirq, TFQ). Основные особенности:

- Полностью автономная реализация
- Поддержка российского оборудования (процессоры Эльбрус, квантовые процессоры МГУ)
- Гибридные квантово-классические алгоритмы
- Оптимизация для GPU вычислений

## Быстрый старт

### Установка
```bash
pip install numpy cupy tensorflow pyopencl mpi4py
```

### Первая программа
```python
from ruquant import QuantumCircuit, StatevectorSimulator

# Создание квантовой схемы
qc = QuantumCircuit(2)
qc.h(0)  # Адамаров гейт на 0-й кубит
qc.cnot(0, 1)  # CNOT между 0 и 1 кубитами

# Запуск симулятора
sim = StatevectorSimulator(2)
sim.run(qc)

# Получение результатов
print("Вероятности состояний:", sim.get_expectation_values())
```

## Основные компоненты

### Квантовые схемы

#### Создание схемы
```python
from ruquant import QuantumCircuit

qc = QuantumCircuit(num_qubits=3)  # Схема с 3 кубитами
```

#### Доступные гейты
```python
qc.h(0)  # Адамаров гейт
qc.x(1)  # Гейт Паули-X
qc.rx(2, 0.5)  # Вращение вокруг X оси на угол 0.5 рад
qc.cnot(0, 1)  # CNOT
qc.measure_all()  # Измерение всех кубитов
```

#### Экспорт в QASM
```python
qasm_str = qc.to_qasm()
print(qasm_str)
```

### Симуляторы

#### Statevector Simulator
```python
from ruquant import StatevectorSimulator

sim = StatevectorSimulator(num_qubits=2, use_gpu=True)  # Использование GPU
sim.run(qc)
print(sim.state)  # Полный вектор состояния
```

#### Noisy Simulator
```python
from ruquant import NoisySimulator

noise_model = {
    "depolarizing": 0.01  # Вероятность ошибки
}
noisy_sim = NoisySimulator(num_qubits=2, noise_model=noise_model)
noisy_sim.run(qc)
noisy_sim.apply_noise()
```

### Гибридные вычисления

#### Квантовый слой для нейросетей
```python
from ruquant.hybrid import QuantumLayer
import tensorflow as tf

model = tf.keras.Sequential([
    QuantumLayer(qc, StatevectorSimulator),
    tf.keras.layers.Dense(10)
])
```

#### VQE алгоритм
```python
from ruquant.hybrid import VQE

# Матрица Гамильтониана
hamiltonian = np.array([[1, 0], [0, -1]])

vqe = VQE(ansatz=qc, hamiltonian=hamiltonian)
result = vqe.optimize(initial_params=[0.1, 0.2])
print("Оптимальные параметры:", result.x)
```

### Аппаратная интеграция

#### Запуск на Эльбрусе
```python
from ruquant.hardware import ElbrusExecutor

elbrus = ElbrusExecutor()
result = elbrus.run(qc)
```

#### Запуск на МГУ QPU
```python
from ruquant.hardware import MSUQPU

msu_qpu = MSUQPU(config={"ip": "qpu.msu.ru"})
result = msu_qpu.run(qc, shots=1000)
print("Результаты измерений:", result["counts"])
```

## Примеры использования

### 1. Алгоритм Гровера
```python
from ruquant import QuantumCircuit, StatevectorSimulator

def grover_algorithm(num_qubits, oracle):
    qc = QuantumCircuit(num_qubits)
    # Инициализация
    for i in range(num_qubits):
        qc.h(i)
    
    # Итерации Гровера
    for _ in range(int(np.pi/4 * np.sqrt(2**num_qubits))):
        # Применение оракула
        oracle(qc)
        # Диффузор
        for i in range(num_qubits):
            qc.h(i)
        qc.x(i for i in range(num_qubits))
        qc.h(num_qubits-1)
        qc.mct(list(range(num_qubits-1)), num_qubits-1)
        qc.h(num_qubits-1)
        qc.x(i for i in range(num_qubits))
        for i in range(num_qubits):
            qc.h(i)
    
    return qc
```

### 2. Квантовая химия (VQE)
```python
from ruquant.hybrid import VQE

# Пример для молекулы H2
hamiltonian = np.array([
    [-1.05, 0, 0, 0],
    [0, -0.81, -0.1, 0],
    [0, -0.1, -0.23, 0],
    [0, 0, 0, 0.62]
])

def ansatz_circuit(params):
    qc = QuantumCircuit(2)
    qc.rx(0, params[0])
    qc.ry(1, params[1])
    qc.cnot(0, 1)
    return qc

vqe = VQE(ansatz=ansatz_circuit, hamiltonian=hamiltonian)
result = vqe.optimize([0.1, 0.2])
print("Энергия основного состояния:", result.fun)
```

## API Reference

### QuantumCircuit
```python
class QuantumCircuit:
    def __init__(self, num_qubits: int)
    def h(self, qubit: int)
    def x(self, qubit: int)
    def rx(self, qubit: int, angle: float)
    def cnot(self, control: int, target: int)
    def measure_all(self)
    def to_qasm(self) -> str
```

### StatevectorSimulator
```python
class StatevectorSimulator:
    def __init__(self, num_qubits: int, use_gpu: bool = False)
    def run(self, circuit: QuantumCircuit)
    def get_expectation_values(self) -> np.ndarray
```

### QuantumLayer
```python
class QuantumLayer(tf.keras.layers.Layer):
    def __init__(self, circuit: QuantumCircuit, simulator_class)
```

## Разработка и вклад

### Сборка из исходников
```bash
git clone https://github.com/ruquant/framework.git
cd framework
pip install -e .
```

### Запуск тестов
```bash
python -m pytest tests/
```

### Руководство по стилю
- PEP 8 для Python кода
- Google-style docstrings
- Типизация (type hints)

### Контрибьюторам
1. Форкните репозиторий
2. Создайте ветку для вашей фичи (`git checkout -b feature/amazing-feature`)
3. Закоммитьте изменения (`git commit -m 'Add some amazing feature'`)
4. Запушьте в форк (`git push origin feature/amazing-feature`)
5. Откройте Pull Request

## Лицензия
Проект распространяется под лицензией Apache 2.0
